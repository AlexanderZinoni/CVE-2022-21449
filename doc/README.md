# CVE-2022-21449 - Vulnérabilité d'une implémentation de ECDSA dans Java
Encadrant : Jean-Marc Talbot (jean-marc.talbot@lis-lab.fr)

Sujet: ![Sujet](Sujet)


## Addition de points sur une courbe elliptique

Ce premier fichier contient les deux scripts indépendants ECC_1 et ECC_3.

### ECC_1

Cette première version n'est pas fonctionnelle et les formules viennent de mes calculs. Le problème principal est que j'avais des difficultés à trouver le signe en ordonnée d'une valeur car je prenais la valeur absolue.

### ECC_3

Cette version est entièrement fonctionnelle, on  retrouve les fonctions suivantes:

    - add()                    effectue la somme de deux points et retourne le résultat
    - compute_points()         prends en argument une courbe, un nombre n et un premier point G et retourne nG
    - generate_key_pair()      retourne la clé publique et celle privée
    - random_genesis()         retourne un point aléatoire sur une courbe elliptique
    - is_point_on_curve()      nous préviens lorsque les points que nous calculons sont trop éloignés de la courbe
    - simplify_point() et rededuce_point() qui permettent d’effacer la valeur en ordonnée d’un point et de la redéduire plus tard pour économiser de la mémoire

Toutes ces fonctions nous permettent de créer une sorte de boîte à outils qui nous sera utile lors de l’implémentation de l’ECIES en python.

Voici son rendu avec les paramètres (a=-1, b=1, G=(-1, 1)) et 2378 points calculés :

![Courbe](Images/EC_curve.JPG)

Le point rose représente la clé publique, et la clé privée et le nombre de points calculés avant de tomber sur la clé publique.
On a donc l'output:
```
Genesis :  (-1, 1)

Public Key:
x:  0.1656382639081782739406509606697608029872418831637
y:  0.9159182240844664063091341348394215722519018290622

Private Key:  2378
```

En réalité cette paire de clé n'est pas vraiment bien sécurisée, car ce programme ne prends pas en compte de modulo, qui est essentiel rendre ces clés bien sécurisées.
J'ai donc réalisé un deuxième script ecc_tools_modular avec le même principe que ecc_tools que je vais détailler plus loin.

## ECIES

Afin de comprendre comment on peut crypter des données grâce à une paire de clés générés à partie d'une courbe elliptique. Ce script ne prends pas non plus en compte de modulo. On retrouve l'algorithme expliqué en détail dans [ce document](Introduction à la cryptographie asymétrique.pdf).

Voici un exemple de son exécution:

```
Genesis (4.32, 8.792131027231111)

Bob's public key: x : 375.19008218274198745165624945675524979496230467241
                  y : -7267.3401176269931001193281876082761415598699597582
Bob's private key:  25272

R is a public point on the curve, R = rG (r is random)
R:  (Decimal('-0.4653662393193413011677221079280358872710426873479'), 0)

S is a shared secret between Alice and Bob, it is not public, S = r(receiver_pub_key)
S:  (Decimal('168.5310401771033185036930238662479743666456322729'), 1)
S2:  168.5310

AES key:  b'I\xaaI\xbf\xa2&\x93k\xda\xbe\xae,\x1ed\x92\xb2]SgDV\xa6\x16\xc9\x083y(\x07o4\xe4'

Original text:  b'Hi bob'
Ciphered text:  b'a\xf4\xe3=\xdf\xe6'
Tag:  b'\x1a\xf4{\x83\x15E\xc1\xb9\xe4g\x94Pu\xa9\xa4\x7f'

S:  (Decimal('168.53103993170841571437322938994661158521169805333'), 1)
S2:  168.5310

AES key:  b'I\xaaI\xbf\xa2&\x93k\xda\xbe\xae,\x1ed\x92\xb2]SgDV\xa6\x16\xc9\x083y(\x07o4\xe4'

The message is authentic:
b'Hi bob'

```

## Courbe elliptiques sur un corps fini

Pour que tout algorithme basé sur les courbes elliptiques soir sécurisé, il faut les implémenter sur un corps fini  Z/pZ.
J'ai donc écrit un script, ecc_tools_modular permettant de réaliser les opérations suivantes:
    - plot(), permet de tracer une fonction (voir la figure ci-dessous)
    - add(), permet de calculer l'addition de deux points
    - multiply(), permet de multiplier un point par un entier naturel
    - generate_key_pair(), permet de générer une paire de clés grâce aux fonctions précédentes
    - random_point(), retourne un point aléatoire appartenant à la courbe
    - suitable_generator, retourne un point pouvant être utilisé comme générateur à partir de l'ordre de la courbe et de l'ordre un certain sous-groupe au cardinal premier.

Voici un exemple de courbe elliptique aux paramètres (26, 3, 31) *(a, b, p)* tracée avec ecc_tools_modular.plot():

![Courbe](Images/modulo_graph.JPG)


Ce script ecc_tools_modular utilise la fonction modular_sqrt() venant du site:
 https://eli.thegreenplace.net/2009/03/07/computing-modular-square-roots-in-python

Ainsi que du code pour l'addition venant du livre '*Initiation à la cryptographie*' de Gilles Dubertret

## L'ordre d'une courbe elliptique

Un des seuls logiciels que j'ai pu trouver nous permettant de trouver l'ordre d'une courbe elliptique est ![sage-math](https://www.sagemath.org/). Dans la console Sagemath, voici comment l'on calcule l'ordre d'une E courbe aux paramètres (26, 3, 31).

```
sage: M = 31
sage: A = 26
sage: B = 3
sage: F = FiniteField(M)
sage: E = EllipticCurve(F, (A, B))
sage: E.order()
33
```
L'ordre de la courbe E est donc de 33.

from Cryptodome.Protocol.KDF import PBKDF2
from Cryptodome.Hash import SHA512
from Cryptodome.Random import get_random_bytes
from Cryptodome.Cipher import AES

import random
import ecc_tools_modular as ecc


detail = False


def encrypt(receiver_pub_key, curve, plaintext):

    genesis = curve[3]
    order = curve[4]

    r = random.randint(1, order - 1)

    if detail:print("R is a public point on the curve, R = rG (r is random)")
    R = ecc.double_and_add(genesis, r, curve)  # R = rG
    if detail:
        print('R:', R[0])
        print('')

        print('S is a shared secret between Alice and Bob, it is not public, S = r(receiver_pub_key)')
    S = ecc.double_and_add(receiver_pub_key, r, curve)  # S = r(receiver_pub_key)
    if detail:
        print('S: ', S[0])
        print('')

    # Use PBKDF to compute AES and MAC keys
    salt = b'\xcc\xb7<+\xbdM\xb2\x9e\x15\xf3gyq^/\xf0'  # Default salt
    AES_key = PBKDF2(str(S), salt, 32, count=1000000, hmac_hash_module=SHA512)
    if detail:
        print('AES key: ', AES_key)
        print('')

    # Encrypt message using AES
    cipher = AES.new(AES_key, AES.MODE_EAX)
    nonce = cipher.nonce
    message_to_bytes = bytes(plaintext, 'utf-8')
    cipher_text, tag = cipher.encrypt_and_digest(message_to_bytes)
    if detail:
        print('Original text: ', message_to_bytes)
        print('Ciphered text: ', cipher_text)
        print('Tag: ', tag)
        print('')

    return R, nonce, cipher_text, tag


def decrypt(receiver_private_key, curve, crypted):

    R = crypted[0]
    nonce = crypted[1]
    cipher_text = crypted[2]
    tag = crypted[3]


    # Derive the shared secret S
    S = ecc.double_and_add(R, receiver_private_key, curve)
    if detail:
        print('S: ', S[0])
        print('')

    # Compute AES and MAC keys
    salt = b'\xcc\xb7<+\xbdM\xb2\x9e\x15\xf3gyq^/\xf0'  # Default salt
    AES_key = PBKDF2(str(S), salt, 32, count=1000000, hmac_hash_module=SHA512)
    if detail:print('AES key: ', AES_key)

    # Encrypt message using AES
    cipher = AES.new(AES_key, AES.MODE_EAX, nonce=nonce)
    plaintext = cipher.decrypt(cipher_text)

    # try:
    #     cipher.verify(tag)
    #     print('')
    #     print('The message is authentic: ')
    #     print(plaintext)
    # except ValueError:
    #     print('Key incorrect or message corrupted')

    return plaintext

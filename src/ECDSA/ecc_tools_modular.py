import random
import matplotlib.pyplot as plt
import numpy as np

I = (0, 0)  # float('inf')


def modular_sqrt(a, p):

    def legendre_symbol(a, p):
        """ Compute the Legendre symbol a|p using
            Euler's criterion. p is a prime, a is
            relatively prime to p (if p divides
            a, then a|p = 0)
            Returns 1 if a has a square root modulo
            p, -1 otherwise.
        """
        ls = pow(a, (p - 1) // 2, p)
        return -1 if ls == p - 1 else ls

    """ Find a quadratic residue (mod p) of 'a'. p
        must be an odd prime.
        Solve the congruence of the form:
            x^2 = a (mod p)
        And returns x. Note that p - x is also a root.
        0 is returned is no square root exists for
        these a and p.
        The Tonelli-Shanks algorithm is used (except
        for some simple cases in which the solution
        is known from an identity). This algorithm
        runs in polynomial time (unless the
        generalized Riemann hypothesis is false).
    """
    # Simple cases
    #
    if legendre_symbol(a, p) != 1:
        return 0
    elif a == 0:
        return 0
    elif p == 2:
        return p
    elif p % 4 == 3:
        return pow(a, (p + 1) // 4, p)

    # Partition p-1 to s * 2^e for an odd s (i.e.
    # reduce all the powers of 2 from p-1)
    #
    s = p - 1
    e = 0
    while s % 2 == 0:
        s //= 2
        e += 1

    # Find some 'n' with a legendre symbol n|p = -1.
    # Shouldn't take long.
    #
    n = 2
    while legendre_symbol(n, p) != -1:
        n += 1

    # Here be dragons!
    # Read the paper "Square roots from 1; 24, 51,
    # 10 to Dan Shanks" by Ezra Brown for more
    # information
    #

    # x is a guess of the square root that gets better
    # with each iteration.
    # b is the "fudge factor" - by how much we're off
    # with the guess. The invariant x^2 = ab (mod p)
    # is maintained throughout the loop.
    # g is used for successive powers of n to update
    # both a and b
    # r is the exponent - decreases with each update
    #
    x = pow(a, (s + 1) // 2, p)
    b = pow(a, s, p)
    g = pow(n, s, p)
    r = e

    while True:
        t = b
        m = 0
        for m in range(r):
            if t == 1:
                break
            t = pow(t, 2, p)

        if m == 0:
            return x

        gs = pow(g, 2 ** (r - m - 1), p)
        g = (gs * gs) % p
        x = (x * gs) % p
        b = (b * g) % p
        r = m


def is_square(a, p):
    return True if pow(a, (p - 1) // 2, p) == 1 else False


def plot(curve):

    a = curve[0]
    b = curve[1]
    p = curve[2]

    if (4 * a ** 3 + 27 * b ** 2) % p == 0:
        return "ERROR"

    array = []

    for x in range(0, p):
        y_squared = (x ** 3 + a * x + b) % p
        y = modular_sqrt(y_squared, p)
        if y != 0:
            array.append([x, y])
            array.append([x, p - y])

    # Traçons l'axe de symétrie, constant sur y = p/2
    x = np.arange(-1, p + 1)
    axis = [p/2] * (p + 2)
    plt.plot(x, axis, 'black')

    # Traçons le nuage de points de la courbe
    x_val, y_val = zip(*array)
    plt.scatter(x_val, y_val)

    # Affichons
    plt.title("Courbe E" + str(curve))
    plt.show()


def add(p1, p2, curve):
    a = curve[0]
    b = curve[1]
    p = curve[2]

    x1 = p1[0]
    y1 = p1[1]
    x2 = p2[0]
    y2 = p2[1]

    if x1 != I and x2 != I:
        if x1 == x2 and y1 == (-y2) % p:
            x3, y3 = I, I

        if x1 == x2 and y1 == y2:
            m = (3 * x1**2 + a) * pow(2*y1, -1, p) % p
            x3 = (-x1 - x2 + m ** 2) % p
            y3 = (-y1 + m * (x1 - x3)) % p

        if x1 != x2:
            m = (y2 - y1) * pow((x2 - x1), -1, p) % p
            x3 = (-x1 - x2 + m ** 2) % p
            y3 = (-y1 + m * (x1 - x3)) % p

    elif x1 == I and x2 != I:
        x3, y3 = x2, y2
    elif x1 != I and x2 == I:
        x3, y3 = x1, y1
    elif x1 == I and x2 == I:
        x3, y3 = I, I

    return x3, y3


def multiply(point, n, curve, return_only_last):  # Deprecated, too slow. Use double_and_add instead
    a = curve[0]
    b = curve[1]
    p = curve[2]

    x1 = point[0]
    y1 = point[1]

    tmp_point = (I, I)
    points_list = [(I, I)]

    for i in range(n):
        # print(str(i)+str(point), '+', tmp_point)
        tmp_point = add(point, tmp_point, curve)
        points_list.append(tmp_point)

    # print(str(n)+str(point), '+', tmp_point)

    if return_only_last:
        return points_list[-1]

    return points_list


def generate_key_pair(curve):
    a = curve[0]
    b = curve[1]
    p = curve[2]
    G = curve[3]
    order = curve[4]

    pub_key = (I, I)

    while pub_key == (I, I):
        priv_key = random.randint(1, order - 1)
        pub_key = double_and_add(G, priv_key, curve)

    return priv_key, pub_key


def random_point(a, b, p):
    y = 0

    while y == 0:
        x = random.randint(0, p)
        y_squared = (x ** 3 + a * x + b) % p
        y = modular_sqrt(y_squared, p)

    return x, y


def suitable_generator(a, b, p, order, subgroup_order):
    h = order // subgroup_order
    G = (I, I)
    while G == (I, I):
        P = random_point(a, b, p)
        G = double_and_add(P, h, (a, b, p))
    return G


def dec_to_bin_list(num):
    return [int(i) for i in list('{0:0b}'.format(num))]


def double_and_add(point, n, curve):
    s = dec_to_bin_list(n)
    res = (I, I)
    tmp = point

    s.reverse()

    for i in s:
        if i == 1:
            res = add(res, tmp, curve)
        tmp = add(tmp, tmp, curve)

    return res

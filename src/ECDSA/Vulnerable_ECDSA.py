import ecc_tools_modular as ecc
import hashlib
import random

#
# message = "My name is Alex"
#
# curve = (26, 3, 31)
# generator = (21, 18)  # found by computing ecc.suitable_generator((26, 3, 31), 33, 11)
# order = 11
# a_private_key, a_public_key = ecc.generate_key_pair(curve, generator, order)
#
detail = False

# if detail:
#     print('')
#     print('    --- Curve parameters --- ')
#     print('Curve equation: y^2 = x^3 +', str(curve[0]) + 'x +', curve[1], 'mod', curve[2])
#     print('G: ', generator)
#     print("Alice's public key:", a_public_key, 'and private key: ', a_private_key)
#     print('Points that belong to to the subgroup: ')
#     print(ecc.multiply(generator, 11, curve, False))
#     print('-------')


def sha3_256(msg):
    hashBytes = hashlib.sha3_256(msg.encode('utf-8')).digest()
    return int.from_bytes(hashBytes, byteorder="big")


def ECDSA_sign(message, curve, G, order, private_key):

    hashed_message = int(str(sha3_256(message))[0: 4])

    r, s = 0, 0

    while r == 0 or s == 0:
        k = random.randint(1, order - 1)
        inv_k = pow(k, -1, order)
        r, y1 = ecc.multiply(G, k, curve, True)
        r = r % order
        s = inv_k * (hashed_message + r * private_key) % order

    if detail:
        print('Generated signature Pair: ')
        print('r = ', r, ' s = ', s)
        print('-------')

    return r, s


def ECDSA_verify(message, curve, pub_key, r, s):

    if detail:print("Verifying the validity of Alices' public key")

    generator = curve[3]
    order = curve[4]

    # Alices' public key must be different than (I, I)
    I = float('inf')
    if pub_key == (I, I):
        if detail:print("  - Alices' public key is different than O : False")
        return False
    if detail:print("  - Alices' public key is different than O : True")

    # Alices' public key must be on the curve
    a = curve[0]
    b = curve[1]
    p = curve[2]
    if ecc.modular_sqrt(pub_key[0] ** 3 + pub_key[0] * a + b, p) % p != pub_key[1] \
            and p - ecc.modular_sqrt(pub_key[0] ** 3 + pub_key[0] * a + b, p) % p != pub_key[1]:
        if detail:print("  - Alices' public key is on the curve: False")
        return False
    if detail:print("  - Alices' public key is on the curve: True")

    # Alices' public key (Q) must respect the equation: order*Q = O
    I = (0, 0) #float('inf')
    if ecc.double_and_add(pub_key, order, curve) != (I, I):
        if detail:print("  - n * Alices' public key  == O : False")
        return False
    if detail:print("  - n * Alices' public key  == O : True")

    if detail:
        print("Alices' public key is valid.")
        print("-------")
        print('Verifying signature pair')

    if r == (I, I) or s == (I, I):
        return False

    e = int(str(sha3_256(message))[0: 4])

    s1 = pow(s, order-2, order)  # Théorème de Fermat

    hs1G = ecc.multiply(generator, (e * s1), curve, True)
    rs1Pubkey = ecc.multiply(pub_key, (r * s1), curve, True)
    x1, y1 = ecc.add(hs1G, rs1Pubkey, curve)

    if x1 == I:
        x1 = 0

    if r == x1 % order:
        if detail:
            print("  - r = r'")
            print('Signature is valid.')
        return True

    return False

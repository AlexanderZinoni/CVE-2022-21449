import ecc_tools_modular as ecc
import hashlib
import random

# detail = False
#
# if detail:
#     print('')
#     print('    --- Curve parameters --- ')
#     print('Curve equation: y^2 = x^3 +', str(alex_curve[0]) + 'x +', alex_curve[1], 'mod', alex_curve[2])
#     print('G: ', generator)
#     print("Alice's public key:", a_public_key, 'and private key: ', a_private_key)
#     print('Points that belong to to the subgroup: ')
#     print(ecc.multiply(generator, 11, alex_curve, False))
#     print('-------')


detail = False


def sha3_256(msg):
    hashBytes = hashlib.sha3_256(msg.encode('utf-8')).digest()
    return int.from_bytes(hashBytes, byteorder="big")


def sign(message, curve, private_key):

    hashed_message = int(str(sha3_256(message)))

    order = curve[4]
    G = curve[3]

    r, s = 0, 0

    while r == 0 or s == 0:
        k = random.randint(1, order - 1)
        inv_k = pow(k, -1, order)
        r, y1 = ecc.double_and_add(G, k, curve)
        r = r % order
        s = inv_k * (hashed_message + r * private_key) % order

    if detail:
        print('Generated signature Pair: ')
        print('r = ', r, ' s = ', s)
        print('-------')

    return r, s


def verify(message, curve, pub_key, signature):

    r = signature[0]
    s = signature[1]

    generator = curve[3]
    order = curve[4]
    if detail:
        print("Verifying the validity of Alices' public key")

    # Alices' public key must be different than (I, I)
    I = (0, 0) # float('inf')
    if pub_key == (I, I):
        if detail:print("  - Alices' public key is different than O : False")
        return False
    if detail:print("  - Alices' public key is different than O : True")

    # Alices' public key must be on the curve
    a = curve[0]
    b = curve[1]
    p = curve[2]
    if ecc.modular_sqrt(pub_key[0] ** 3 + pub_key[0] * a + b, p) % p != pub_key[1] \
            and p - ecc.modular_sqrt(pub_key[0] ** 3 + pub_key[0] * a + b, p) % p != pub_key[1]:
        if detail:print("  - Alices' public key is on the curve: False")
        return False
    if detail:print("  - Alices' public key is on the curve: True")

    # Alices' public key (Q) must respect the equation: order*Q = O
    if ecc.double_and_add(pub_key, order, curve) != (I, I):
        if detail:print("  - n * Alices' public key  == O : False")
        return False
    if detail:print("  - n * Alices' public key  == O : True")

    if detail:
        print("Alices' public key is valid.")
        print("-------")
        print('Verifying signature pair')

    if r == (I, I) or s == (I, I):
        return False

    if (1 >= r or r > p) and (1 >= s or s > p):
        if detail:
            print(1 >= r)
            print(r > p)
            print(1 >= s)
            print(s > p)
            print("  - Signature pair are ints in [1, n-1]: False")
        return False
    if detail: print("  - Signature pair are ints in [1, n-1]: True")

    e = int(str(sha3_256(message))) % order

    s1 = pow(s, -1, order)

    hs1G = ecc.double_and_add(generator, (e * s1), curve)
    rs1Pubkey = ecc.double_and_add(pub_key, (r * s1), curve)
    x1, y1 = ecc.add(hs1G, rs1Pubkey, curve)

    if x1 == I and y1 == I:
        return False

    if r == x1 % order:
        if detail:
            print("  - r = r'")
            print('Signature is valid.')
        return True

    return False

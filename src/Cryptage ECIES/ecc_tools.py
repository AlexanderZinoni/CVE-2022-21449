import numpy as np
import matplotlib.pyplot as plt
import random
import warnings
from decimal import Decimal, getcontext

warnings.filterwarnings("ignore", category=RuntimeWarning)

# Changed float Decimal precision to 50 places
getcontext().prec = 200


def random_genesis(x_min, x_max, curve):
    a = curve[0]
    b = curve[1]

    genesis_x = random.randint(x_min * 100, x_max * 100) / 100
    genesis_y = genesis_x ** 3 + genesis_x * a + b
    max_tries = 100
    i = 0

    while genesis_y < 0 and i < max_tries:
        genesis_x = random.randrange(x_min * 100, x_max * 100) / 100
        genesis_y = genesis_x ** 3 + genesis_x * a + b
        i += 1

    if np.isnan(genesis_y):
        raise TypeError

    return genesis_x, np.sqrt(genesis_y)


def add(P1, P2, curve_param):

    a = Decimal(curve_param[0])
    q = Decimal(curve_param[2])
    I = float('inf')

    x1 = Decimal(P1[0])
    y1 = Decimal(P1[1])
    x2 = Decimal(P2[0])
    y2 = Decimal(P2[1])

    if x1 != I and x2 != I:
        if P1 == P2:
            m = Decimal(Decimal(1) / Decimal(2) * (3 * x1 ** 2 + a) / y1)

        else:
            m = Decimal((y2 - y1) / (x2 - x1))

        x3 = -x1 - x2 + m ** 2
        y3 = -y1 + m * (x1 - x3)

    elif x1 == I and x2 != I:
        x3, y3 = x2, y2
    elif x1 != I and x2 == I:
        x3, y3 = x1, y1
    else:  # x1 == I and x2 == I:
        x3, y3 = I, I

    if is_point_on_curve((x3, y3), curve_param):
        return x3, y3

    print('Point ', x3, y3, 'not on curve!')
    return x3, y3


def compute_points(g, n, C, isDisplay=False, onlyLastPoint=True):
    # Computes n points of C, starting with the genesis(g) and returns them in a list, ordered.

    # print('')
    # print('Genesis : ', g)

    points = [g]
    previous_point = g

    for i in range(1, n + 1):
        tmp_point = add(g, previous_point, C)
        points.append(tmp_point)
        previous_point = tmp_point

        if isDisplay:  # DEBUGGING
            print('')
            print('Point', i, ':', previous_point)

    if onlyLastPoint:
        return points[-1]

    return points


def is_point_on_curve(point, curve):
    x0 = point[0]
    y0 = point[1]
    a = curve[0]
    b = curve[1]

    rounding = 6

    y_test = np.sqrt(x0 ** 3 + a * x0 + b)
    y_test = round(y_test, rounding)

    y0 = round(y0, rounding)

    #  print(y_test, abs(y0)) #  DEBUGGING

    if y_test == abs(y0):
        return True

    return False


def simplify_point(point):
    # print(point)
    if point[1] > 0:
        sign = 0
    else:
        sign = 1

    return point[0], sign


def rededuce_point(simplified_point, Curve):
    x = simplified_point[0]
    if simplified_point[1] == 0:
        return x, np.sqrt(x**3 + Curve[0]*x + Curve[1])
    else:
        return x, -np.sqrt(x**3 + Curve[0]*x + Curve[1])


def generate_key_pair(genesis, curve):

    r = random.randint(10000, 50000)
    values = compute_points(genesis, r, curve, False, False)

    pub_key = values[-1]

    return pub_key, r

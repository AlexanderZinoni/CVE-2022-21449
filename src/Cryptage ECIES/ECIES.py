from Cryptodome.Protocol.KDF import PBKDF2
from Cryptodome.Hash import SHA512
from Cryptodome.Random import get_random_bytes
from Cryptodome.Cipher import AES

import random
import ecc_tools as ecc

Curve = (-1, 1, 31)
G = ecc.random_genesis(3, 6, Curve)
print('')
print('Genesis', G)
print('')

b_public_key, B_private_key = ecc.generate_key_pair(G, Curve)
print("Bob's public key: x :", b_public_key[0],)
print("                  y :", b_public_key[1])
print("Bob's private key: ", B_private_key)
print("")

message = 'Hi bob'


def encrypt(receiver_pub_key, genesis, curve, plaintext):
    r = 1000000  # random.randint(100000, 1000000)

    print("R is a public point on the curve, R = rG (r is random)")
    R = ecc.compute_points(genesis, r, curve)  # R = rG
    R = ecc.simplify_point(R)
    print('R: ', R)
    print('')

    print('S is a shared secret between Alice and Bob, it is not public, S = r(receiver_pub_key)')
    S = ecc.compute_points(receiver_pub_key, r, curve)  # S = r(receiver_pub_key)
    S = ecc.simplify_point(S)
    print('S: ', S)
    print('S2: ', str(S)[10:18])
    print('')

    # Use PBKDF to compute AES and MAC keys
    salt = b'\xcc\xb7<+\xbdM\xb2\x9e\x15\xf3gyq^/\xf0'
    AES_key = PBKDF2(str(S)[10:18], salt, 32, count=1000000, hmac_hash_module=SHA512)
    print('AES key: ', AES_key)
    print('')

    # Encrypt message using AES
    cipher = AES.new(AES_key, AES.MODE_EAX)
    nonce = cipher.nonce
    message_to_bytes = bytes(plaintext, 'utf-8')
    cipher_text, tag = cipher.encrypt_and_digest(message_to_bytes)
    print('Original text: ', message_to_bytes)
    print('Ciphered text: ', cipher_text)
    print('Tag: ', tag)
    print('')

    return R, nonce, cipher_text, tag


def decrypt(receiver_private_key, curve, R, nonce, cipher_text, tag):

    R = ecc.rededuce_point(R, curve)

    # Derive the shared secret S
    S = ecc.compute_points(R, receiver_private_key, curve)
    S = ecc.simplify_point(S)
    print('S: ', S)
    print('S2: ', str(S)[10:18])
    print('')

    # Compute AES and MAC keys
    salt = b'\xcc\xb7<+\xbdM\xb2\x9e\x15\xf3gyq^/\xf0'
    AES_key = PBKDF2(str(S)[10:18], salt, 32, count=1000000, hmac_hash_module=SHA512)
    print('AES key: ', AES_key)

    # Encrypt message using AES
    cipher = AES.new(AES_key, AES.MODE_EAX, nonce=nonce)
    plaintext = cipher.decrypt(cipher_text)

    try:
        cipher.verify(tag)
        print('')
        print('The message is authentic: ')
        print(plaintext)
    except ValueError:
        print('Key incorrect or message corrupted')


RCD = encrypt(b_public_key, G, Curve, message)
decrypt(B_private_key, Curve, RCD[0], RCD[1], RCD[2], RCD[3])
